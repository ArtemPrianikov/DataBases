/*1. В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных.
Переместите запись id = 1 из таблицы shop.users в таблицу sample.users. Используйте транзакции.*/

-- создадим копию существующей базы данных
mysqldump shop > sample.sql

-- создадим новую БД sample
CREATE DATABASE sample;
USE sample

-- подгрузим файл из дампа
SOURCE sample.sql

-- хмм, возможно, это всё было лишнее, но ладно: удаляю значения из таблицы sample.users:
TRUNCATE users;

-- сначала научусь делать простую транзакцию
START TRANSACTION;
INSERT INTO sample.users (name) VALUES ('TOM');
COMMIT;

/* получил таблицу:
+----+------+-------------+---------------------+---------------------+
| id | name | birthday_at | created_at          | updated_at          |
+----+------+-------------+---------------------+---------------------+
|  1 | TOM  | NULL        | 2019-09-14 14:37:57 | 2019-09-14 14:37:57 |
+----+------+-------------+---------------------+---------------------+*/

-- вариант с удалением
START TRANSACTION;
DELETE FROM sample.users WHERE id=1;
COMMIT;

-- скопировать имя, айди, и все остальные поля из первоначальной таблицы:
START TRANSACTION;
INSERT INTO sample.users
	SELECT *
		FROM shop.users WHERE id=1;
COMMIT;
/*что-то не сработало, оказалось, в исходной таблице нет пользователя с таким id
+----+--------------------+-------------+---------------------+---------------------+
| id | name               | birthday_at | created_at          | updated_at          |
+----+--------------------+-------------+---------------------+---------------------+
| 12 | Геннадий           | 1990-10-05  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 13 | Наталья            | 1984-11-12  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 14 | Александр          | 1985-05-20  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 15 | Сергей             | 1988-02-14  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 16 | Иван               | 1998-01-12  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 17 | Мария              | 1992-08-29  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
+----+--------------------+-------------+---------------------+---------------------+*/

START TRANSACTION;
INSERT INTO sample.users
	SELECT *
		FROM shop.users WHERE id=12;
COMMIT;
/* получилось перенести пользователя:
+----+------------------+-------------+---------------------+---------------------+
| id | name             | birthday_at | created_at          | updated_at          |
+----+------------------+-------------+---------------------+---------------------+
|  2 | TOM              | NULL        | 2019-09-14 14:48:22 | 2019-09-14 14:48:22 |
| 12 | Геннадий         | 1990-10-05  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
+----+------------------+-------------+---------------------+---------------------+*/

-- думаю, логично было бы оставить запиcь в поле updated_at по дефолту
INSERT INTO sample.users (id, name, birthday_at, created_at)
	SELECT id, name, birthday_at, created_at
		FROM shop.users WHERE id=13;
COMMIT;
/* Теперь поле updated_at будет заполняться в момент транзакции автоматически
+----+------------------+-------------+---------------------+---------------------+
| id | name             | birthday_at | created_at          | updated_at          |
+----+------------------+-------------+---------------------+---------------------+
|  2 | TOM              | NULL        | 2019-09-14 14:48:22 | 2019-09-14 14:48:22 |
| 12 | Геннадий         | 1990-10-05  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 13 | Наталья          | 1984-11-12  | 2019-09-06 11:41:53 | 2019-09-14 15:04:18 |
+----+------------------+-------------+---------------------+---------------------+*/

-- теперь реализуем удаление из первоначальной таблицы

INSERT INTO sample.users (id, name, birthday_at, created_at)
	SELECT id, name, birthday_at, created_at
		FROM shop.users WHERE id=14;
	DELETE FROM shop.users WHERE id=14;
COMMIT;

/* select * from users; в этой таблице появился
+----+--------------------+-------------+---------------------+---------------------+
| id | name               | birthday_at | created_at          | updated_at          |
+----+--------------------+-------------+---------------------+---------------------+
|  2 | TOM                | NULL        | 2019-09-14 14:48:22 | 2019-09-14 14:48:22 |
| 12 | Геннадий           | 1990-10-05  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 13 | Наталья            | 1984-11-12  | 2019-09-06 11:41:53 | 2019-09-14 15:04:18 |
| 14 | Александр          | 1985-05-20  | 2019-09-06 11:41:53 | 2019-09-14 15:07:35 |
+----+--------------------+-------------+---------------------+---------------------+


/* select * from shop.users; из этой таблицы удалён
+----+------------------+-------------+---------------------+---------------------+
| id | name             | birthday_at | created_at          | updated_at          |
+----+------------------+-------------+---------------------+---------------------+
| 12 | Геннадий         | 1990-10-05  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 13 | Наталья          | 1984-11-12  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 15 | Сергей           | 1988-02-14  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 16 | Иван             | 1998-01-12  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
| 17 | Мария            | 1992-08-29  | 2019-09-06 11:41:53 | 2019-09-06 11:41:53 |
+----+------------------+-------------+---------------------+---------------------+


/* 2. Создайте представление, которое выводит название name товарной позиции из таблицы products и соответствующее
название каталога name из таблицы catalogs.*/

-- для чистоты эксперимента, и учитывая опыт прошлых ошибок, создадим позицию, которая не имеет присвоенного catalog_id:
INSERT INTO products VALUES(DEFAULT, 'MOUSE-123', 'good, reliable mouse', 500, NULL, DEFAULT, DEFAULT)//


-- теперь если мы применим самый очевидный JOIN, эта позиция не попадёт:
SELECT p.name, c.name as 'категория'
	FROM products as p
	INNER JOIN catalogs as c ON c.id=p.catalog_id;
	
-- тут нужен левый джоин:
SELECT p.name, c.name as 'категория'
	FROM products as p
	LEFT JOIN catalogs as c ON c.id=p.catalog_id;

/* теперь позиция попадает, и можно делать из этой таблицы представление
+-------------------------+----------------------+
| name                    | категория            |
+-------------------------+----------------------+
| Intel Core i3-8100      | Процессоры           |
| Intel Core i5-7400      | Процессоры           |
| AMD FX-8320E            | Процессоры           |
| AMD FX-8320             | Процессоры           |
| ASUS ROG MAXIMUS X HERO | Мат.платы            |
| Gigabyte H310M S2H      | Мат.платы            |
| MSI B250M GAMING PRO    | Мат.платы            |
| MOUSE-123               | NULL                 |
+-------------------------+----------------------+*/

CREATE VIEW products_catalogs AS
SELECT p.name, c.name as 'категория'
	FROM products as p
	LEFT JOIN catalogs as c ON c.id=p.catalog_id;

SELECT * FROM products_catalogs;
-- всё работает, таблица сохранилась в представлении
